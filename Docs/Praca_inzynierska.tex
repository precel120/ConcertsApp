\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{polski}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{indentfirst}
\usepackage{geometry}
\usepackage{setspace}
\usepackage[hyphens]{url}
\usepackage[style=numeric, backend=biber]{biblatex}
\usepackage{array}
\usepackage{float}
\usepackage{listings}

\addbibresource{bibliography.bib}
\graphicspath{{./images/}}

\setstretch{1.5}

\geometry{
  a4paper,
  left=30mm,
  top=25mm,
  right=10mm,
  bottom=20mm
}

\begin{document}
\begin{sloppypar}
\includepdf{strona_tytulowa.pdf}

\tableofcontents
\newpage

\textbf{Abstract:}
The aim of this thesis is to design and implement web application for promoting cultural events and selling tickets for them. 
There are plenty of similar applications, but this one was created with aim to simplify and shorten to maximum, user's experience and time spent with the app.
User is presented with simple, yet very clear, interface and is provided with secure and effortless payments. \\
This work compares apps from the competition, pointing out the best aspects of each, in order to show what features and functionalities where taken into 
consideration while designing the app. It provides information with current online shopping trends, as well as
with the most popular online payment methods.\\
The result of the analysis and designing is web application called ConcertsApp.

\bigbreak
\textbf{Streszczenie:}
Celem niniejszej pracy dyplomowej jest zaprojektowanie oraz zaimplementowanie aplikacji webowej do promocji wydarzeń kulturowych oraz sprzedaży biletów na nie.
Na rynku jest wiele podobnych aplikacji, jednakże ta została stworzona, z myślą by uprościć i zminimalizować do maksimum, 
czas i doświadczenie z obcowaniem z aplikacją.
Użytkownik ma do czynienia, z prostym, jednakże bardzo czytelnym interfejsem aplikacji oraz z bezpiecznymi i niewymagającymi 
dużego zaangażowania płatnościami.\\
Niniejsza praca porównuje aplikacje konkurencji i przedstawia ich najlepsze aspekty, 
w celu pokazania, które ich cechy i funkcjonalności były brane pod uwagę podczas tworzenia aplikacji. 
Również zawiera informację o trendach jeśli chodzi o zakupy przez internet, jak również najpopularniejsze metody płatności w sieci.\\
Rezultatem wyżej wymienionej analizy oraz projektowania jest aplikacja webowa o nazwie ConcertsApp.

\section{Wprowadzenie}
{
  W dobie trwającego rozwoju technologicznego, każdy aspekt życia codziennego jest usprawniany i przenoszony
  do internetu. Nieinaczej jest z promowaniem i sprzedażą biletów na wydarzenie kulturowe pokroju:
  spektakli w teatrze, koncertów, festiwali. Aplikacja ConcertsApp ma służyć dokładnie temu,
  ma zminimalizować czas, jaki należałoby kiedyś przeznaczyć na zdobycie biletów. Czy też na uzyskanie
  informacji o wydarzeniach z interesującej konsumenta dziedziny, lub odbywających się w pobliżu.
  \subsection{Problematyka}
  {
    Czas pędzi nieustannie, w obecnych czasach wydawać by się mogło, że nawet pędzi niczym TGV. Ani człowiek się obejrzy i z poniedziałku staje się piątek. 
    Ludzie są wiecznie zabiegani, nie mają czasu, dlatego firmy, twórcy programów i aplikacji, cały czas wymyślają coraz to nowe sposoby, jak uprościć i 
    skrócić czas, poświęcany na codzienne czynności.
    Dlatego też wiele usług, sklepów, serwisów przenoszonych jest w całości do sieci, lub mają sieciowy odpowiednik sklepu/oddziału stacjonarnego. 
    W obecnych czasach zdecydowanie ciężej jest prosperować firmom nie posiadającym strony lub sklepu internetowego. 
    Na rynku jest zbyt duża konkurencja, aby móc sobie pozwolić na brak obecności w sieci i/lub mediach społecznościowych. 
    Poszukując, przykładowo, krawca w okolicy, wpisuje się odpowiednią frazę w wyszukiwarkę internetową. Jeśli strona nie pojawi się w wynikach wyszukiwania, 
    lub przynajmniej informacja o firmie i jej oceny na Google Maps, to nie ma możliwości, 
    żeby dana osoba skorzystała z usług krawca, który mimo posiadanego fachu, nie widnieje w sieci. 
    Każda osoba/firma chcąca podbić rynek i osiągnąć sukces musi posiadać minimum stronę na jednym z portali społecznościowych, np. FaceBook, 
    oraz widnieć w Google Maps.\\
    Minimalizacja czasu poświęcanego na codzienne czynności dotyczy również, strefy takiej jak kultura. 
    Chcąc wybrać się np. na spektakl w teatrze, są dwie możliwości: kupno biletu bezpośrednio w teatrze oraz zakup biletu przez stronę teatru 
    lub stronę udostępniającą bilety.
    Pierwszy z nich wymaga przebicia się przez zakorkowane miasto, możliwe, że nawet stania w kolejce po bilet i dopiero powrót do domu. 
    Potrafi to pochłonąć ogromną ilość czasu, na co nie każdy może sobie pozwolić. 
    Dlatego powstała alternatywa, czyli zakup biletu w internecie, zakup jest bez kolejek, bez wychodzenia z domu i cały proces może potrwać góra 10 minut. 
    W usprawnienie tej części rynku celuje powstała na potrzeby niniejszej pracy inżynierskiej aplikacja, 
    aby przyspieszyć i ułatwić dostęp do jakże ważnej części ludzkiego życia, jaką jest kultura i sztuka. 
  }
  \subsection{Cel i założenia pracy}
  {
    Celem niniejszej pracy dyplomowej jest stworzenie aplikacji webowej, która umożliwi w łatwy i szybki
    sposób na promowanie wydarzeń kulturowych i zakup biletów na nie. Zakup odbywać się będzie za pomocą
    płatności online, jedynie podając dane karty kredytowej lub debetowej.\par
    Zakres pracy obejmuję zaprojektowanie i implementację aplikacji klienckiej i serwerowej, przy
    wykorzystaniu, najnowszych i bardzo popularnych na rynku pracy technologii. Do strony klienckiej
    został wykorzystany React, z kolei do stworzenia serwera użyto Node.JS.
  }
  \subsection{Struktura pracy inżynierskiej}
  {
    Pierwszy rozdział ma posłużyć jako wprowadzenie do problemu podjętego w niniejszej pracy dyplomowej.
    Następny przedstawia aspekty takie jak: konkurencyjne rozwiązania do tworzonej aplikacji,
    analiza najpopularniejszych metod płatności online, opowiada o bazach danych oraz przybliża
    metody tworzenie aplikacji webowych.
    Trzeci rozdział przedstawia wykorzystane technologie do implementacji aplikacji oraz uzasadnia dlaczego
    akurat ona została wybrana, a nie inna.
    Czwarty rozdział pokazuje jak przebiegał proces twórczy, czyli projektowanie i implementacja. 
    Piąty rozdział mówi o tym, jak wygląda proces obcowania z aplikacją, od strony klienta.
  }
}

\section{Zakupy internetowe, analiza konkurencji i techniczne aspekty aplikacji}
{
  \subsection{Zakupy internetowe}
  {
    Sklepy internetowe z roku na rok rosną w siłę, przybywa ich liczba w zatrważającym tempie. 
    Aż 73\% ankietowanych w raporcie przygotowanym przez Gemius Polska\cite{gemius-report} deklaruje kupowanie online i ta forma zakupów cieszy się niezmiennie dobrym 
    wizerunkiem wśród kupujących. Brak sklepu internetowego stanowi ogromną niekorzyść dla obecnych przedsiębiorców. 
    Zakupy online charakteryzują się dużo większym wyborem produktów, łatwością w porównywaniu ofert, czy też łatwością w znalezieniu interesujących produktów. 
    Lecz, to nie z wyżej wymienionych powodów, sklepy w sieci cieszą sie taką popularnością.
    Wśród najczęściej wymienianych powodów są: dostępność przez całą dobę (aż 82\% wybrało ten powód), brak konieczności wyjazdu do sklepu - 78\%, 
    nieograniczony czas wyboru - 72\% oraz atrakcyjniejsze ceny niż w sklepach tradycyjnych - 71\%.\\
    Niestety taka forma zakupów ma też swoje słabe strony, najpopularniejszymi
    wymienianymi problemami są: wysokie koszta dostawy, długi czas oczekiwania na dostawę, irytujące reklamy produktów, wcześniej poszukiwanych.
    Również bardzo często wymienianą przeciwnością jest uszkodzona przesyłka w transporcie, wynikać to może ze źle zapakowanej i zabezpieczonej paczki lub z winy 
    firmy kurierskiej i jej pracowników.\\
    Co jednak sprawia, że klienci decydują się na wybór danego portalu na zakupy?\\
    Najczęściej wybór sklepu pada dzięki kodom rabatowym, dopiero w dalszej kolejności, klienci patrzą na aspekty takie jak:
    dokładne informacje o warunkach zamówienia, ostępne na stronie dane firmy czy przejrzysta i funkcjonalna strona internetowa. 
    Wydawać by się mogło, że to na te kolejne cechy portali, powinno się w pierwszej kolejności
    zwracać uwagę, bo to dzięki nim w od razu można stwierdzić czy strona może być oszutwem, czy też nie.
    }
    \subsection{Analiza najpopularniejszych internetowych metod płatności}
  {
    Najpopularniejszymi metodami płatności w internecie, według raportu "E-commerce w Polsce 2020"\cite{gemius-report} są kolejno:
    \begin{itemize}
      \item szybki przelew przez serwis płatności np. payU, przelewy24
      \item przelew tradycyjny
      \item płatność kartą płatniczą przy składaniu zamówienia
      \item płatności mobilne np. BLIK
    \end{itemize}
    Nie zostały wymienione płatności pokroju wysyłki za pobraniem, płatności w sklepie przy odbiorze, ponieważ nie są to płatności realizowane online, 
    a tych dotyczy analiza przedstawiona w niniejszym rozdziale.\\
    Zdecydowanie nie powinna dziwić obecność szybkich przelewów na pierwszym miejscu tego rankingu. Aż 70\% ankietowanych odpowiedziało, 
    że choć raz korzystało z tej metody, przy robieniu zakupów przez internet. Cechują się błyskawiczynym czasem realizacji, w przeciwieństwie do tradycyjnych
    przelewów. Zaledwie 46\% ankietowanych zdecydowało się choć raz na przelew tradycyjny. Różnica jest znaczna, jednakże nie powinna ona dziwić, ponieważ 
    to oszczędność czasu sprawia, że klienci decydują się na zakupy online w pierwszej kolejności. Przelewy tradycyjne dodatkowo wydłużają czas realizacji 
    zamówienia, ponieważ ich przetwarzanie odbywa się jedynie w dni robocze, o wyznaczonych godzinach, różnych, w zależności od banku.\\
    Na płatność kartą decyduje się 40\% pytanych, jest to dość zaskakujące, zważywszy na fakt, że jest to zdecydowanie jedna z najszybszych metod płatności. 
    Do jej realizacji niezbędne jest jedynie numer karty, data wygaśnięcia oraz kod CVV. Powodem na dość niską popularność tej metody, mogą być dwie rzeczy, 
    strach przed podawaniem danych karty, żeby nie zostały skradzione, lub brak karty podczas składania zamówienia.
    Druga z nich wydaję się być bardziej prawdopodobna, mało kto kupując 
    produkty przez internet ma akurat przy sobie kartę płatniczą, by odczytać z niej niezbędne liczby. 
    Zdecydowanie łatwiej jest zalogować się do banku i wykonać przelew, czy to tradycyjny, czy szybki.\\
    Dziwić może obecność płatności mobilnych, na ostatnim miejscu, z zaledwie 35\% wykorzystania. 
    Jest to sposób bardzo wygodny, zważywszy na fakt iż mało kto nie posiada przy sobie telefonu. 
    Potrzebna jest jeszcze tylko aplikacja banku i można dokonywać dowolnych płatności. 
    W przypadku BLIK-u generowany jest sześciocyfrowy ciąg liczb, który wystarczy wpisać w odpowienie pole, zatwierdzić płatność w aplikacji i gotowe.
  }
  \subsection{Analiza istniejących portali do promowania i dystrybucji biletów na wydarzenia kulturowe}
  {
    Najpopularniejszymi portalami zbliżonymi do tworzonej aplikacji są zdecydowanie:
    \begin{itemize}
      \item Eventim
      \item GoingApp
    \end{itemize}
    Eventim jest znacznie starszym portalem, co można stwierdzić chociażby, po jego szacie graficznej, łatwo to zauważyć porównująć do wyżej wymienionego GoingApp. 
    W swojej ofercie ma wydarzenia pokroju: koncertów, przedstawień teatralnych, oper czy baletów.\\
    Same bilety sprzedawane są w formie papierowej, przychodzą na maila, lub istnieje możliwość zakupu biletu mobilnego. 
    Kupno może odbyć się zarówno poprzez strone internetową, jak również poprzez aplikację mobilną. 
    Płatności można dokonać za pomocą przelewu tradycyjnego, karty kredytowej, szybkiego przelewu Dotpay\\
    GoingApp charakteryzuje się bardziej nowoczesną i przejrzystą szatą graficzną w porównaniu do Eventim. 
    Oferty obu portali są bardzo do siebie zbliżone, lecz tutaj można znaleźć takie wydarzenia, jak chociażby imprezy związane z filmem czy jedzeniem.
    Jednakże nie posiada on biletów na balet lub opery.\\
    Wejściówki można, podobnie jak w Eventim nabyć poprzez ich stronę internetową lub aplikację mobilną. 
    Sam bilet jest dostępny w formie dokumentu PDF, lub kodu QR, dostęp do niego mamy zarówno poprzez maila, którego otrzymujemy zaraz po zakupie, oraz aplikację.
    Użytkownik może dokonać płatności za pomocą systemów płatniczych takich jak: payU, eCard, MasterPass oraz Paymento\textregistered \\
    Aplikacja webowa, tworzona na potrzeby niniejszej pracy inżynierskiej, czerpie z obu portali najlepsze cechy. 
    Z Eventim czerpie różnorodność wydarzeń, z kolei z GoingApp przejrzystość interfejsu i bilety w formie, bardzo popularnego kodu QR.
    Metody płatności zostają ograniczone do kart płatniczych: debetowej i kredytowej. Podawane są numer karty, data ważności oraz kod CVV.
  }
  \subsection{Bazy danych jako środek przechowywania danych}
  {
    "Baza danych to zorganizowany zbiór ustrukturyzowanych informacji, czyli danych, zwykle przechowywany w systemie komputerowym w formie elektronicznej. 
    Bazą danych steruje zwykle system zarządzania bazami danych (DBMS). 
    Dane i system DBMS oraz powiązane z nimi aplikacje razem tworzą system bazodanowy, często nazywany w skrócie bazą danych.". \cite{oracle-db}
    Innymi słowy jest to kontener na dane, o dowolnej postaci, mogą to być liczby, ciągi znaków, a nawet zdjęcia czy filmy. 
    Dane te nie są, najczęściej, przetrzymywane lokalnie na komputerach, tylko na serwerach czy w chmurze. \\
    Dlaczego więc korzysta się z baz danych a nie np. z arkuszy kalkulacyjnych?\\
    Odpowiedź jest bardzo prosta, arkusze kalkulacyjne nie zostały stworzone do pracy z ogromną ilością danych, przy jednoczesnym dostępie, nawet kilkuset lub więcej użytkowników.
    Są wręcz idealne do pracy z mniejszą ilościa danych dla jednego lub małej grupy użytkowników, którzy nie potrzebują wielu skomplikowanych funkcji do manipulacji danymi.
    Bazy danych z kolei, przeznaczone są do pracy z ogromnymi ilościami informacji, umożliwiając dodatkowo jednoczesny dostęp do nich, wielu użytkownikom na raz. 
    Co więcej praca z bazami danych, charakteryzuje się wysokim bezpieczeństwem i szybkością wykonywanych operacji. Operacje na danych, tworzenie zapytań odbywa się 
    za pomocą logiki i języka o wysokim stopniu złożoności. Jako przykład może posłużyć, zdecydowanie najpopularniejszy z nich, czyli język zapytań SQL.\\
    Bazy danych dzielimy, między innymi na:
    \begin{itemize}
      \item relacyjne
      \item hurtownie danych
      \item NoSQL
      \item chmurowe
    \end{itemize}
    Relacyjne bazy danych zyskały ogromną popularność w latach 80\cite{oracle-db}. Dane zorganizowane są w tabelach, składające się z wierszy i kolumn. Po dziś dzień stanowią 
    jedne z najpopularniejszych baz danych, jak nie najpopularniejsze, dostępne na rynku. Przykładami relacyjnych baz danych są: MySQL i Microsoft SQL Server.\\
    Hurtownie danych, inaczej centralne repozytorium danych, to typ bazy danych wykorzystywany do wykonywania zapytań i analizy. 
    Ma on umożliwić i wspierać działania z zakresu analizy biznesowej, w szczególności analityki. Często operuje na danych historycznych, pochodzących z wielu źródeł. 
    Jej umiejętności analityczne pozwalają przedsiębiorstwom przetrzymywać cenne dane biznesowe, które ułatwiają podejmowanie decyzji.\cite{oracle-warehouse}\\
    Baza danych NoSQL, inaczej nierelacyjna, od relacyjnych baz różni je przede wszystkim to, że w relacyjnych mają jasną strukturę organizacji danych. 
    W nierelacyjnych dane, pochodzące z tej samej kolekcji, mogą posiadać kompletnie różne atrybuty. 
    Szerzej na temat baz NoSQL zostanie omówione w następnym podrodziale.\\
    Ostatnim typem bardzo popularnym na rynku baz danych są bazy chmurowe. Bazy te charakteryzują się przede wszystkim tym, że dane przetrzymywane są na prywatnej,
    publicznej lub hybrydowej platformie przetwarzania danych w chmurze. 
    Najpopularniejszymi bazami w chmurze są Microsoft Azure SQL Database, Oracle Database, Google Cloud SQL oraz Amazon Relational Database Service.
  }
  \subsection{Nierelacyjne bazy danych}
  {
    "Bazy danych NoSQL są zamiennie nazywane „nierelacyjnymi” lub „nie SQL”, aby podkreślić fakt, że potrafią obsłużyć ogromne ilości szybko zmieniających się, 
    nieustrukturyzowanych danych innymi sposobami niż relacyjna (SQL) baza danych z wierszami i tabelami." \cite{mc-nosql}\\
    Co jednak wyróżnia bazy typu NoSQL na tle relacyjnych baz danych?\\
    Ich głównym wyróżnikiem zupełnie inny schemat przechowywania danych. W bazach nierelacyjnych dane nie są przechowywane w tabelach, mogą być dowolnie skalowane, 
    każdy wiersz może zawierać różne kolumny (atrybuty opisujące dany obiekt), nie jest wymuszana relacja między obiektami.\\
    Bazy typu SQL są znacząco lepsze jeśli skalowalność zachodzi wertykalnie, a horyzontalnie atrybuty są jasno określone. Nie jest wskazane aby każdy obiekt, z jednej 
    tabeli, opisany był innymi atrybutami.\\
    W przypadku prostych obiektów, opisanych małą ilością atrubutów, lepszym wyborem będą bazy typu NoSQL. Z kolei dla bardziej skomplikowanych encji, lepiej wykorzystać 
    bazy relacyjne, ze względu na ich schludność i uporządkowanie, zdecydowanie łatwiej uniknąć niechcianego bałaganu i błędów.\\
    Bazy NoSQL dzielimy, ze względu na typ na\cite{agh-nosql}:
    \begin{itemize}
      \item Klucz - wartość
      \item Dokumentowe
      \item Grafowe
      \item Kolumnowe
    \end{itemize}
    Pierwsze z nich opierają się na kolekcji słowników, w których z kluczem powiązane są wartości różnych atrybutów encji. Dodatkowo wykorzystuje się funckje haszujące 
    do przyspieszenia odczytu. Jako przykłady mogą posłużyć: Windows Azure Table Storage oraz Amazon SimpleDB.\\
    Bazy dokumentowe stosuje się do przechowywania dokumentów posiadających różne atrybuty oraz mają możliwość zagnieżdżania jednych dokumentów w drugie. Przykładem 
    wymienionego typu baz jest wykorzystane przy implementacji projektu baza MongoDB.\\
    Bazy grafowe oparte są na grafach i algorytmach grafowych. Każdy obiekt jest innym węzłem w grafie, a relacje między nimi to krawędzie. Przykłady to: Titan, Giraph.
    Ostatnim typem baz nierelacyjnych są bazy kolumnowe. Oparte są na architekturze hybrydowej, wykorzystują techniki i podejści relacyjnej bazy oraz bazy klucz-wartość 
    do przechowywania schematów danych. Przykładem takiej bazy jest Cassandra.\\
    Podsumowując bazy nierelacyjne lepiej sprawdzają się przy małej ilości atrybutów, łatwiej uniknąć bałaganu, dlatego też to właśnie nierelacyjna baza danych została wybrana 
    do realizacji projektu, a dokładniej MongoDB. O tym dlaczego akurat MongoDB, zostanie przedstawione w następnym rodziale 3.5.
  }
  \subsection{Techniki tworzenia aplikacji webowych}
  {
    Przy tworzeniu aplikacji webowych istnieją dwa podejścia, mówiące o tym jak należy tworzyć aplikację. 
    Są to Single-Page Application (SPA) oraz Multiple-Page Application (MPA, czyli tradycyjne strony internetowe). \\
    SPA jest aplikacją webową lub stroną internetową, która nie przeładowuje swoich stron za pomocą serwera oraz interakcja z użytkownikiem zachodzi, 
    za pomocą dynamicznego zmieniania aktualnie wyświetlanej strony. Kod źródłowy strony jest zapisywany tylko przy pierwszym załadowaniu, oraz 
    dodatkowe zasoby są ładowane, tylko wtedy kiedy jest to wymagane, w zależności od zachowania użytkownika. 
    SPA są interaktywne oraz przyjazne użytkownikowi, są bardziej responsywne niż tradycyjne strony, ponieważ ładują się tylko raz i ich komunikacja z serwerem,
    jest ograniczona do minimum. \cite{spa-conference} \\
    MPA jest klasycznym podejściem do tworzenia stron internetowych. 
    Praktycznie każde kliknięcie, w dowolną rzecz na stronie, wysyła zapytanie do serwera o wyrenderowanie nowej strony w przeglądarce.
    Każda strona jest innym plikiem, nie ma możliwości jak w SPA, że renderowany jest tylko wymagany komponent. Cała strona musi być ponownie rerenderowana. \\
    Kiedy należy używać jakiego podejścia? \\
    Microsoft w poradniku do tworzenia aplikacji w .NET, proponuje poniższą tabelkę decyzyjną\cite{mc-spa}:
    \begin{center}
      \begin{table}
        \begin{tabular}{ | m{5cm} | m{5cm}| m{5cm} | } 
          \hline
          Factor & Traditional Web App & Single-Page Application \\
          \hline
          Required Team Familiarity with JavaScript/TypeScript & Minimal & Required \\
          \hline
          Support Browsers without Scripting & Supported & Not Supported \\
          \hline
          Minimal Client-Side Application Behavior & Well-Suited & Overkill \\
          \hline
          Rich, Complex User Interface Requirements & Limited & Well-Suited \\
          \hline
        \end{tabular}
        \caption{\label{tab:decision-table}Tabela decyzyjna wyboru pomiędzy SPA, a MPA. \cite{mc-spa}}
      \end{table}
    \end{center}
    Do stworzenia aplikacji na potrzeby pracy inżynierskiej zostało wybrane podejście SPA, gwarantuje ono szybsze, przyjemniejsze oraz bardziej responsywne 
    zachowanie aplikacji dla użytkownika.
  }
  \subsection{REST API}
  {
    REST oznacza w skrócie Representational State Transfer, jest to architektura zaproponowana przez Roya Fieldinga, jako nowe podejście do projektowania 
    usług internetowych. Architektura ta jest niezależna od wszelkich podstawowych protokołów, w tym HTTP. Jednak w najbardziej typowych implementacjach REST 
    protokół HTTP pełni funkcję protokołu aplikacji.\cite{mc-rest}
    Architektura REST oparta jest na kilku głównych zasadach, oto 6 najważniejszych\cite{mc-rest}:
    \begin{itemize}
      \item Interfejsy API są oparte na zasobach - dowolnym obiekcie, danych lub usłudze, które są dostępne dla klienta
      \item Zasób ma identyfikator URI służący do unikatowej identyfikacji tego zasobu
      \item Interakcja z usługą odbywa się poprzez wymianę reprezentacji zasobów. Najpopularniejszym formatem wymiany danych jest JSON.
      \item Do wykonywania operacji na zasobach używa się standardowych zapytań HTTP, najczęściej używane operacje to GET, POST, PUT, PATCH i DELETE.
      \item Interfejsy API REST korzystają z bezstanowego modelu żądań. Każde zapytanie do serwera musi posiadać niezbędne informacje do zrozumienia zapytania. Stan sesji jest przetrzymywany tylko i wyłącznie po stronie klienta.
      \item Interfejsy API REST są sterowane za pomocą hipermedialnych linków, zawartych w reprezentacji.
    \end{itemize}
    Najpopularniejszymi metodami do operacji na zasobach, jak zostało wyżej wymienione są:
    \begin{itemize}
      \item GET - pobiera reprezentację danego zasobu np. strona potrzebuje listę wszystkich produktów dostępnych do zakupu na stronie
      \item POST - tworzy nowy zasób, np. użytkownik rejestruje się na danej stronie internetowej i przy kliknięciu "ZAREJESTRUJ" wysyłane jest zapytanie POST, o dodaniu nowego użytkownika do bazy danych.
      \item PUT - tworzy zasób lub aktualizuje istniejący
      \item PATCH - wykonuje częściową aktualizację zasobu, np. użytkownik zmienia adres zamieszkania, podany wcześniej
      \item DELETE - usuwa zasób
    \end{itemize}
    W zależności od podanego URI, może zostać zwrócony zasób w formie kolekcji lub pojedynczego elementu. 
    Przykładowo podając URI \url{https://adventure-works.com/orders}, dla metody GET uzyskamy listę wszystkich zamówień. 
    Z kolei podając URI \url{https://adventure-works.com/orders/1} uzyskamy pojedyncze zamówienie, np. o id = 1.
    Każda metoda będzie zachowywać się podobnie dla podanych wyżej URI, z tą różnicą, że przykładowo metoda POST zamiast pobrać listę wszystkich zamówień, utworzy nowe zamówienie, 
    metoda PUT zaktualizuje wszystkie zamówienia, w zadany sposób.\\
    Architektura REST API cieszy się ogromną popularnością, między innymi z tego powodu została wybrana do stworzenia aplikacji.
  }
  \subsection{Projektowanie i tworzenie systemu informatycznego}
  {
    W inżynierii oprogramowania, czyli inaczej wiedzy technicznej, opisującej wszystkie fazy cyklu życia oprogramowania, istnieje wiele różnych modeli 
    cyklu życia oprogramowania. Do najpopularniejszych należą: kaskadowy, piramidy oraz spiralny. Każdy z nich w podobny sposób przedstawia każdy krok, 
    jaki powinien przejść program, aby mógł zostać wypuszczony na rynek. Na poniższym rysunku przedstawiono jak wygląda model kaskadowy, w dalszej części zostaną 
    omówione, pokrótce, jego poszczególne etapy.
    \begin{figure}[H]
      \centering
      \includegraphics[width=0.9\textwidth]{model_kaskadowy}
      \caption{Model kaskadowy \cite{cascade}}
      \label{fig:cascade}
    \end{figure}
    Każda z faz cechuje się innym zestawem czynności jakie należy wykonać. 
    Faza określenia wymagań cechuje się, jak sama nazwa wskazuje, określeniem wymagań. Ustalane są cele, a następnie zamieniane są na faktyczne wymagania 
    jakie musi posiadać oprogramowanie. Wymagania dzielimy odpowiednio na funkcjonalne i niefunkcjonalne. 
    Wymagania funkcjonalne to takie, które opisują funkcję lub czynności wykonywane przez system. 
    Z kolei niefunkcjonalne opisują ograniczenia, przy zachowaniu których system powinien realizować swoje funkcję.\\
    W fazie projektowania odpowiada się na pytania, jak system ma działać i jak system ma być zaimplementowany. W wyniku czego powstaje projekt i projekt implementacji.\\
    Kolejno przechodzi się do fazy implementacji, jest to moment, w którym wszystkie czynności związane z projektowaniem zostają zakończone i wcielone w faktyczny program.\\
    Po fazie implementacji następuje faza testowania. 
    W tej fazie następuje sprawdzenie systemu, czy jest zgodny z postawionymi wymaganiami, 
    oraz czy nie posiada jakichś błędów mogących doprowadzić do niepożądanego działania lub błędów z samym wykonywaniu się oprogramowania.\\
    Na samym końcu cyklu życia oprogramowania, znajduje się część przeznaczona na konserwację programu. 
    W tej fazie poprawiana jest jakość produktu, dostosowanie oprogramowania do zmian zachodzących w środowisku pracy oraz usuwanie wcześniej niewykrytych błędów.\\
    Warto również wspomnieć o fazie dokumentacji, jest ona wykonywana równolegle z praktycznie wszystkimi pozostałymi czynnościami. 
    Tworzona jest dokumentacja, w której znajdują się takie elementy jak: podręcznik użytkownika, opis instalacji czy podręcznik administratora. 
    Dokumentacja jest integralną częścią projektu i nie powinna być pomijana lub traktowana bez należytej uwagi.
  }
}

\section{Narzędzia i technologie wybrane do realizacji projektu}
{
  \subsection{Node.js}
  {
    "Node.JS jest jest wieloplatformowym oprogramowaniem o otwartym kodzie, 
    które pozwala deweloperom na tworzenie wszelkiego rodzaju oprogramowania w języku JavaScript pracującym po stronie serwera. 
    Jest to środowisko uruchomieniowe, które działa poza przeglądarką, współpracujące bezpośrednio z systemem operacyjnym. 
    W ten sposób środowisko Node udostępnia swoim aplikacjom API systemu operacyjnego, w tym dostęp do systemu plików, bibliotek systemowych czy uruchomionych procesów, 
    w tym serwerów HTTP."\cite{mozilla-node} Wartym wspomnienia jest fakt, że jest oparty na silniku JavaScript Chrome V8.\\ 
    Zalety jakie niesie ze sobą Node:
    \begin{itemize}
      \item wysoka wydajność, został zaprojektowany tak aby optymalizować wydajność i skalowalność aplikacji webowych
      \item pracując nad kodem po stronie klienta jak i po stronie serwera, poruszamy się w tym samym języku programowania
      \item dostęp do menadżera pakietów np. Yarn czy NPM, dzięki niemu uzyskuje się dostęp do setek tysięcy przeróżnych pakietów.
      \item jest przenośny. Można korzystać z niego zarówno na systemie macOS, Linux, jak również Windows.
      \item Dostęp do ogromnego community, gotowego służyć pomocą.
    \end{itemize}
    Node.JS jest bardzo uniwersalnym narzędziem, nie służy jedynie do tworzenia serwerów backendowych dla stron internetowych. Można za jego pomocą tworzyć 
    zwykłe aplikacje, aplikacje z dziedziny IoT(Internet of Things), posiada nawet pakiety do uczenia maszynowego. Za pomocą Node jesteśmy w stanie 
    wykonać przeróżne rzeczy ogranicza jedynie znajomość JavaScript oraz własna wyobraźnia. \\
    \begin{figure}[H]
      \centering
      \includegraphics[width=0.9\textwidth]{most_popular_frameworks.PNG}
      \caption{Najpopularniejsze frameworki i biblioteki według ankiety Stack Overflow\cite{stack-survey}}
      \label{fig:backend}
    \end{figure}
    Jak zostało zaprezentowane na obrazku \ref{fig:backend}, Node.JS cieszy się ogromną popularnością. Uzyskał 51.9\% na 33 913 ankietowanych, 
    tę grupę stanowili jedynie profesjonalni developerzy.
    \begin{figure}[H]
      \centering
      \includegraphics[width=0.9\textwidth]{most_popular_web_frameworks.PNG}
      \caption{Najpopularniejsze webowe frameworki według ankiety Stack Overflow\cite{stack-survey}}
      \label{fig:web-frameworks}
    \end{figure}
    Dodatkowo Express, czyli framework do Node.JS, za pomocą, którego został stworzony cały backend projektu, znajduje się na drugim miejscu w rankingu popularności 
    wśród frameworków backendowych, osiągnął popularność na poziomie 20.9\%. Wyprzedza takie frameworki jak: Java Spring, Flask, Django, Laravel czy Ruby on Rails, 
    jedynie ASP.NET plasuje się wyżej w rankingu. 
  }
  \subsection{React.js}
  {
    "React A JavaScript library for building user interfaces."\cite{react} Tłumacząc na polski, React jest biblioteką do tworzenia interfejsów użytkownika. 
    React jest oparty na komponentach, każdy komponent może posiadać własny stan i nim zarządzać, korzystając z komponentów można tworzyć bardzo złożone UI. 
    Sporym plusem Reacta jest fakt, że raz poznany umożliwia również tworzenie aplikacji mobilnych przy wykorzystaniu React Native. Co dodatkowo wyróżnia React 
    jest własna składnia, zbliżona do XML-a, czyli JSX. Jest to mieszanka HTML-a i JavaScriptu, możemy dzięki niemu bez najmniejszych przeszkód umieszczać 
    tagi znane z HTML-a, w kodzie JavaScriptowym, podczas tworzeniu komponentów. Dodatkowo własne komponenty, również podczas tworzenia struktury dokumenty, mają 
    składnię taką jak HTML. \\
    Kolejnym wyjątkowym aspektem Reacta jest Virtual DOM. Jest to koncept programistyczny gdzie wirtualna reprezentacja UI jest 
    przetrzymywana w pamięci i synchronizowana z prawdziwym DOM-em. 
    Umożliwia to podawanie UI w jakim stanie ma się znajdować i jakie komponenty mają być wyrenderowane, również upewnia się, że faktyczny DOM odpowiada temu stanowi. 
    Ściągą to z programisty konieczność stworzenia samemu takich elementów jak: obsługę wydarzeń np. kliknięcie przycisku, manualne aktualizowanie DOM-u oraz manipulację atrybutami.
    \begin{figure}[H]
      \centering
      \includegraphics[width=0.9\textwidth]{how_react_works.PNG}
      \caption{Skrótowa prezentacja działania Reacta}
      \label{fig:how-react-works}
    \end{figure}
    Konkurencje dla Reacta stanowi Angular i Vue, jednakże to React króluje zarówno jeśli chodzi o popularność, pobrania, gwiazdki na GitHubie, liczbę pakietów, które są zależne od Reacta. 
    Niekwestionowanym mistrzem jest również w kategoriach GitHub "Used by", tematach tworzonych na GitHubie.\cite{frontend-popularity} Dodatkowym atutem przemawiającym za Reactem jest 
    ilość pracy na rynku. Jak zostało zaprezentowane na obrazku poniżej, ponownie React króluje i w tej kategorii. 
    \begin{figure}[H]
      \centering
      \includegraphics[width=0.9\textwidth]{frontend_jobs.jpg}
      \caption{Zapotrzebowanie na rynku, na specjalistów z danego frameworku.\cite{accenture}}
      \label{fig:frontend-jobs}
    \end{figure}
  }
  \subsection{TypeScript}
  {
    Czym jest TypeScript? W skrócie jest to JavaScript rozszerzający go o statyczne definicje typów, takie jak np. string, number czy boolean. 
    Został stworzony przez firmę Microsoft, przy wsparciu Google.
    Pisząc w TypeScripcie nie trzeba używać typów, interfejsów, typów generycznych czy też innych elementów udostępnianych. 
    Można pisać zwykły JavaScript i pomimo, że zostaną wyświetlone błędy informujące o nieokreślonym typie, cały kod wykona się mimo wszystko.
    Każdy kod napisany w JavaScripcie będzie w pełni funkcjonalnym kodem TypeScriptowym.
    Jednakże pisząc w TypeScripcie przeglądarka nie rozumie tego języka, zna tylko i wyłącznie JavaScript, dlatego kod musi być skompilowany przy pomocy 
    TypeScriptowego kompilatora lub Babela.\cite{typescript-docs} 
    Dodatkowo sprawia to, że napisany kod będzie działał na dowolnym urządzeniu i przeglądarce, o ile te wspierają JavaScript.\\
    Dlaczego programiści decydują się na TypeScript?\\
    Wynika to przede wszystkim z obecności typów, pisząc w JavaScripcie należałoby pisać dodatkowe linijki kodu tylko i wyłącznie sprawdzające np. czy 
    dane otrzymane przez serwer są odpowiednich typów, TypeScript robi wszystko za programistę. 
    Błędy związane z typami należą do najczęściej popełnianych wśród programistów JavaScript, szczególnie w projektach o większej skali bardzo łatwo o takie błędy.
    Typować można nie tylko zmienne, ale też funkcje, zarówno argumenty jakie przyjmuje oraz typ zwracany.\\
    TypeScript to nie tylko typy, posiada liczne dodatkowe funkcje, których JavaScript nie posiada. Są to chociażby wcześniej wspomniane interfejsy, 
    można deklarować własne typy, typy generyczne oraz typy wyliczeniowe - enumy. Inną niedostępna funkcją jest chociażby przeciążanie funkcji. 
    Wyglądem nie przypomina to kodu znanego z języków programowania typu Java czy C++, lecz spełnia dokładnie takie samo zadanie jak w tamtych językach.
  }
  \subsection{Najistotniejsze wykorzystane biblioteki}
  \label{section:most-important-libraries}
  {
    W tej sekcji mogłoby znaleźć się ogromna ilość przeróżnych bibliotek, które są używane w projekcie. Create-React-App(służy do generowania projektów Reactowych), 
    sam w sobie pobiera kilkadziesiąt bibliotek. Tutaj jednak znajdą się tylko biblioteki, który zostały dodane na potrzeby projektu i warto o nich wspomnieć, a są to:
    \begin{itemize}
      \item Express
      \item Mongoose
      \item Stripe
      \item Nodemailer
      \item QRCode
      \item Material UI
      \item React Redux
      \item jsonwebtoken
    \end{itemize}
    Pierwsza z nich czyli Express, jest minimalistycznym, elastycznym frameworkiem do Node.js. Dostarcza takie mechanizmy jak\cite{express}:
    \begin{itemize}
      \item Tworzenie funkcji obsługujących żądania metod HTTP i routing.
      \item Integrację z różnymi silnikami do generowania widoków, opartych na szablonach stron.
      \item Konfiguracja podstawowych ustawień aplikacji webowych np. port.
      \item Dodatkowe przetwarzanie żądań warstwy pośredniej(Middleware).
    \end{itemize}
    Sam w sobie Express jest minimalistyczny i nie posiada wielu istotnych funkcji. Dopiero zewnętrzne biblioteki umożliwiają takie aspekty jak: logowanie użytkowników,
    walidacja danych, zarządzanie ciasteczkami czy też parsowanie.\\
 
    Drugi z nich czyli Mongoose, służy do porozumiewania się z bazą danych MongoDB. Umożliwia w prosty sposób tworzenie modeli danych, walidację, przeszukiwanie bazy danych 
    oraz zapisywanie zmian w bazie. Lecz sam w sobie jest zdefiniowany jako narzędzie do modelowanie danych.\\
 
    Kolejną spośród wymienionych bibliotek jest Stripe. Stripe jest biblioteką do obsługi płatności internetowych, poprzez podanie danych karty kradytowej lub debetowej, 
    wysyłane jest zapytanie do API, które tworzy płatność, pobiera odpowiednią kwotę z konta i informuje o powodzeniu lub niepowodzeniu transakcji.\\
 
    Nodemailer jest prostym modułem dla aplikacji opartych na Node.js umożliwiającym i znacznie upraszczającym wysyłanie maili. Jest on o tyle niezbędny, że każdy bilet wysyłany jest na maila, 
    jedynie zalogowani użytkownicy mają wgląd do historii transakcji i mogą podejrzeć kod QR z poziomu aplikacji. Użytkownicy goście nie mają innego dostępu do biletów, jedynie 
    przychodzą one na maila.\\
 
    QRCode jest biblioteką do generowania kodów QR. Jest to technologia bardzo obecnie popularna i wygodna, praktycznie każdy obecny smartfon posiada czytnik kodów QR.\\
 
    Material UI jest jedną z najpopularniejszych bibliotek komponentów. Służy do tworzenia interfejsów użytkownika, bazując na gotowych komponentach, dodatkowo znacznie 
    usprawniające tworzenie responsywnych interfejsów.\\
 
    React Redux jest to biblioteka do Reacta, udostępniająca przetrzymywanie globalnego stanu aplikacji i dostępu do niego z każdego jej poziomu. Jest to o tyle przydatne 
    narzędzie, że bez jego wykorzystania developer byłby zmuszony do przekazywania danych między komponentami w bardzo nieelegancki i toporny sposób. Redux umożliwia 
    manipulację i dostęp do globalnego stanu z dowolnego komponentu.\\
 
    Jsonwebtoken jest biblioteką do tworzenia JWT, służący przede wszystkim do autoryzacji użytkownika, szczególnie przydatne jest to przy logowaniu. Szerzej o JWT 
    przedstawione zostanie w jednej z kolejnych podsekcji.\\
  }
  \subsection{MongoDB}
  {
    MongoDB jest typem nierelacyjnej bazy danych, posiada strukturę zbliżoną do JSON-a, czyli klucz-wartość. Oznacza to, że każdy dokument może mieć inną strukturę, 
    zupełnie inaczej niż jest to w relacyjnych bazach. MongoDB charakteryzuje się wysokim bezpieczeństwem, dużą skalowalnością i łatwością obsługi. 
    Świadczyć o tym może fakt, że z usług tej bazy danych korzystają takie firmy jak Google, Adobe czy ebay. \\
    MySQL vs MongoDB (informacje pochodzą z \cite{mongovsmysql})\\
    MySQL jest popularną, darmową i open-source relacyjną bazą danych stworzoną przez firmę Oracle. Jak to w relacyjnych bazach danych, informacje przechowywane są w formie tabel, 
    wykorzystywany jest język zapytań SQL.\\
    MongoDB również jest darmowy oraz open-source, dane przechowywane są w formie dokumentów, jako pary klucz-wartość.\\
    Biorąc pod lupę wydajność obu baz, ciężko jest porównywać dwie zupełnie różne bazy, o dwóch różnych typach. Jednakże można zauważyć, że MySQL jest szybsze przy pobieraniu dużej liczby rekordów,
    z kolei MongoDB jest zdecydowanie szybsze przy dodawaniu i aktualizacji dużej liczby rekordów.\\
    Innym istotnym aspektem porównawczym jest skalowalność. MongoDB zważywszy na fakt, iż jest bazą nierelacjną posiada strukturę dokumentu, zbliżoną do JSONa, jest wysoce skalowalna i 
    można to robić w bardzo prosty sposób, bez obaw o utraty czy uszkodzenia danych. MySQL jest dużo bardziej ograniczone, ponieważ jest bazą relacyjną. 
    Jedyne dostępne opcje na skalowanie to skalowanie pionowe lub tworzenie replik do odczytu.\\
    Innym istotnym aspektem jest elastyczność bazy. Tutaj zdecydowanie króluje MongoDB, każdy z rekordów może posiadać inne pola, o innych typach, podczas gdy w MySQL 
    nie jest to dostępne. Tam struktura tabeli jest sztywna i nie jest możliwe by choćby jeden rekord miał inne pole zamiast obecnie występującego. \\
    Decyzja o wyborze MongoDB była dość prosta, biblioteka Mongoose do Node.JS, jest łatwa i przyjemna w obsłudze, dodatkowo korzyści płynące z korzystania z MongoDB są na tyle 
    interesujące, że to na tę bazę danych padł wybór.
  }
  \subsection{JWT - JSON Web Token}
  {
    Jest otwartym standardem (RFC 7519), który definiuje kompaktową i samowystarczalną możliwość, bezpiecznej transmisji danych w formacie JSON\cite{jwt}. 
    Informacje przekazywane za pomocą JWT są weryfikowalne i można im ufać, ponieważ są podpisywane cyfrowo. 
    JWT można podpisać za pomocą algorytmu HMAC przy wykorzystaniu sekretu lub pary klucza publicznego i prywatnego przy wykorzystaniu algorytmów RSA lub ECDSA. 
    Sekret jest tajnym hasłem przechowywanym przez serwer do podpisywania i autoryzacji tokenów.
    Najczęstszym powodem wykorzystania JWT jest autoryzacja użytkownika, czy to przy logowaniu, czy też 
    przy sprawdzaniu dostępu do np. jakiegoś url w aplikacji. Innym popularnym zastosowaniem jest wymiana informacji.\\
    JSON Web Token składa się z następujących elementów: nagłówka (Header), payloadu oraz podpisu, oddzielonych od siebie kropkami. 
    Przeważnie struktura JWT wygląda następująco: xxxxx.yyyyy.zzzzz\\
    Nagłówek przeważnie składa się z dwóch części: typu wygenerowanego tokena oraz algorytmu, jakim został podpisany.\\
    Payload jest odpowiedzialny za przetrzymywanie danych zawartych w tokenie.\\
    Zarówno nagłówek, jak i payload są kodowane za pomocą Base64-URL do stworzenia odpowiednio pierwszej i drugiej części JWT.\\
    Do stworzenia podpisu należy wziąć zakodowany nagłówek i payload, sprecyzować algorytm szyfrujący oraz prywatny klucz lub sekret i podpisać to.
    Przykładowo przy wykorzystaniu algorytmu HMAC SHA256, podpis zostanie stworzony w następujący sposób:\\
    \begin{figure}[H]
      \centering
      \includegraphics[width=0.9\textwidth]{JWT_signature.PNG}
      \caption{Sposób tworzenia podpisu JWT przy wykorzystaniu algorytmu HMAC SHA256.}
      \label{fig:jwt_signature}
    \end{figure}
    Wynikiem takiej operacji są trzy ciągi znaków Base64-URL, oddzielonych od siebie kropkami.\\
    JWT w tworzonej aplikacji wykorzystywane jest przy rejestracji, logowaniu oraz dostępu do niektórych ścieżek. 
    Rejestracja przebiega następująco:
    \begin{enumerate}
      \item Użytkownik podaje dane niezbędne do rejestracji.
      \item Użytkownik zatwierdza podane dane.
      \item Wysyłane jest zapytanie do serwera, gdzie tworzony jest token, hashowane jest hasło i tworzony nowy wpis w bazie danych.
    \end{enumerate}
    Dzięki temu po zalogowaniu użytkownik ma dostęp do inaczej niedostępnej sekcji, czyli historii zamówień, gdzie można znaleźć wszystkie posiadane bilety wraz z ich kodami QR.
  }
}

\section{Proces tworzenia aplikacji}
{
  Dobrą praktyką i ogólnie przyjętą zasadą jest rozpoczęcie tworzenia aplikacji webowej od strony backendowej. Zgodnie z tym podejściem prace rozpoczęły się od backendu, 
  został stworzony podstawowy serwer logujący proste hasło "działa". Kolejnym etapem było podpięcie bazy danych MongoDB.
  \begin{lstlisting}[caption=Kod odpowiadający za integrację z MongoDB., captionpos=b]
    import express from 'express';
    import mongoose from 'mongoose';
    import keys from './config/keys';
    require('./models/Ticket');

    mongoose.connect(keys.mongoURI, { useNewUrlParser: true, useUnifiedTopology: true });

    const app = express();
  \end{lstlisting}
  Do połączenia z bazą danych wykorzystywana jest biblioteka Mongoose, o której szerzej w sekcji \ref{section:most-important-libraries}.
  W następnej kolejności został wygenerowany za pomocą Create-React-App, projekt Reactowy, będący bazą dla frontendu aplikacji. 
  Niezbędnym zabiegiem do połączenia obu stron aplikacji, jest dodanie oprogramowania pośredniczącego proxy, aby połączenie między serwerem stworzonym w Node.JS, a 
  stroną Reactową mogło zostać nawiązane. Do tego została wykorzystana bibliotek http-proxy-middleware. Do funkcjonowania tego połączenia wystarczyło stworzyć nowy plik 
  setupProxy.js, prezentujący się następująco:
  \begin{lstlisting}[caption=Proxy Middleware do połączenia strony frontendowej z backendową., captionpos=b]
    const {createProxyMiddleware} = require('http-proxy-middleware');

    module.exports = function (app) {
        app.use("/api", createProxyMiddleware({target: "http://localhost:5000"}));
    } 
  \end{lstlisting}
  Kolejnym celem było stworzenie prostego forma, służącego do przyjmowania danych osobowych użytkownika oraz dane karty płatniczej. Następnie powstał cały system płatności, 
  a dokładniej dane podane przez użytkownika są przekazywane do serwera, który następnie tworzy "Payment Intent", czyli Stripową(\ref{section:most-important-libraries}), 
  nową płatność.
  \begin{lstlisting}[caption=Obsługa przekazywania danych klienta na serwer w celu dokonania nowej płatności., captionpos=b]
      const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        if(!stripe || !elements) {
          return;
        }

        const { data: clientSecret } = await axios.get("/api/payment_intent");

        const cardElement = elements.getElement(CardElement);
        
        setIsProcessing(true);
        
        const fullName = firstName + " " + lastName;
        const paymentMethodReq = await stripe.createPaymentMethod({
          type: 'card', 
          card: cardElement!,
          billing_details: {email: email, name: fullName, phone: phoneNumber}
        });
        if (paymentMethodReq.error) {
          console.log('error', paymentMethodReq.error);
          setIsProcessing(false);
          return;
        }
        const { error } = await stripe.confirmCardPayment(clientSecret, {
          payment_method: paymentMethodReq.paymentMethod?.id,
        });
        if (error) {
          setIsProcessing(false);
          return;
        }
        console.log('payment method', paymentMethodReq.paymentMethod);
      }
  \end{lstlisting}
  \begin{lstlisting}[caption=Podstawowy system obsługi płatności przez serwer, captionpos=b]
    app.get("/api/payment_intent", async (req, res) => {
      try {
        const paymentIntent = await stripe.paymentIntents.create({
          amount: 400,
          currency: "pln",
          payment_method_types: ['card'],
          metadata: {integration_check: "accept a payment"},
        });
        res.status(200).send(paymentIntent.client_secret);
      } catch (error) {
        res.status(500).json({ statusCode: 500, message: error.message });
      }
    });
  \end{lstlisting}
  Jednakże sam system płatności to mało, niezbędne było aby był tworzony nowy rekord w bazie danych, odpowiadający biletowi dla danego wydarzenia. 
  Warunkiem jaki musi zajść, aby bilet mógł zostać stworzony jest by liczba biletów, na wydarzenie nie przekroczyła określonej, maksymalnej liczby dostępnych biletów.
  \begin{lstlisting}[caption=Tworzenie nowego biletu w bazie danych., captionpos=b]
    Ticket.find({ eventId: event?.id }, (error, tickets) => {
      if (!error) {
        if (event?.toJSON().maxTicketsAmount - 1 < tickets.length) {
          res.status(403).send("No tickets left");
          return;
        }
      } else res.status(404).send("No tickets found") 
    });
    const ticket = new Ticket({
      email: email.trim(),
      firstName: firstName.trim(),
      lastName: lastName.trim(),
      phoneNumber: phoneNumber.trim(),
      eventId: eventFound.id,
      purchaseDate: new Date(),
    });
    ticket.save((error) => {
      if (error) {
        res.status(500).send("Ticket cannot be added to database");
        return;
      }
    });
  \end{lstlisting}
  Kolejny etap odbył się po stronie frontendowej, została stworzona mała karta, prezentująca w skrócie każde z wydarzeń. Dla celów estetycznych, niezbędne było 
  aby widoczne były na nich zdjęcia, co dodatkowo wymagało, aby były one pobierane z serwera.
  \begin{lstlisting}[caption={Linijka kodu odpowiadająca za podpięcie folderu public, w którym znajdują się zdjęcia wydarzeń.}, captionpos=b]
    app.use(express.static("public"));
  \end{lstlisting}
  W następnej kolejności został wykonany wstępny Nav Bar z możliwością wyszukiwania wydarzenia po nazwie, jak również filtrowania po typach wydarzeń. Dla wygody 
  programisty wymagało to podpięcia biblioteki Redux, w celu stworzenia globalnego stanu, który może być współdzielony przez wszystkie komponenty. 
  Ponieważ, filtrowane wartości są, w późniejszym etapie rozwoju aplikacji, użyteczne.\\
  Następnym bardzo istotnym etapem, było stworzenie walidacji danych przesyłanych na serwer w formie do płatności, oraz danych wpisywanych przez użytkownika.
  Do walidacji wykorzystane zostały biblioteki express-validator oraz React-Hook-Form, odpowiednio dla strony backendowej i frontendowej. 
  Sprawdzane są typy danych podawane w formie oraz za pomocą REGEX, czy podana wartość, np. adres email, jest zgodny ze wzorem.
  \begin{lstlisting}[caption={Przykładowy pattern walidacji emaila, po stronie klienta.}, captionpos=b]
    <Input
      name="email"
      type="email"
      id="input__email"
      autoComplete="off"
      inputRef={register({
        required: "Please specify email.",
        pattern: {
          value:
            /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
          message: "Invalid email.",
        },
      })}
      required
    />
  \end{lstlisting}
  Kolejną funkcjonalnością zaimplementowaną, zostało wysyłanie maili. 
  Do klient, po dokonaniu poprawnej płatności, zostaje wysłany email, z informacją o poprawnie dokonanej płatności i docelowo z kodem QR, będący biletem.
  Do tego została wykorzystana biblioteka nodemailer\ref{section:most-important-libraries}.
  \begin{lstlisting}[caption=Kod odpowiadający za wysyłanie emaili., captionpos=b]
    const mailTemplate = `
        <h1>Hello ${firstName} ${lastName}</h1>
        <p>Thanks for buying ticket for ${event.nameOfEvent}, in ${event.place}, taking place on ${event.dateOfEvent}</p>
        <img src="${qr}">
        `;

      const message = {
        from: env.email,
        to: email,
        subject: `Ticket for ${event.nameOfEvent}`,
        html: mailTemplate,
      };
      transporter.sendMail(message, (error, info) => {
        if (error) {
          let err = new StatusError("Error while sending mail", 500);
          return next(err);
        } else console.log("Mail sent:", info.response);
      });
  \end{lstlisting}
  Kolejnym, ale nie ostatnim elementem, było generowanie, wysyłanie w mailu oraz przetrzymywanie kodów QR. 
  Kod jest generowany na podstawie id biletu, znajdującego się w bazie danych. 
  Do jego realizacji wykorzystano bibliotekę QRCode\ref{section:most-important-libraries}.
  \begin{lstlisting}[caption=Kod odpowiadający za generowanie kodów QR., captionpos=b]
    const qr = await toDataURL(ticket.id);
    if (!qr) {
      let err = new StatusError("Error while creating QR Code", 400);
      return next(err);
    }
  \end{lstlisting}
  Ostatnią funkcjonalnością, ale nie ostatnim krokiem było logowanie się i rejestracja użytkowników. 
  Do jej zrealizowania było potrzebne kilka bibliotek, a dokładniej: jsonwebtoken, bcrypt, o tej pierwszej szerzej w rozdziale \ref{section:most-important-libraries}, 
  druga z kolei odpowiada za hashowanie hasła.
  Logowanie się użytkownika, umożliwia mu dostęp do historii zakupionych biletów, na wydarzenia. Dodatkowo otrzymuje dostęp do kodów QR swoich biletów. 
  Niezalogowany użytkownik ma możliwość zakupu biletu, kod QR otrzymuje na maila, ale w razie np. utraty maila nie ma innej opcji dostępu do niego. 
  Co czyni rejestrację użytkownika bardzo atrakcyjnym.\\
  Finalnym krokiem zostało dodanie styli CSS i w pełni wykorzystanie biblioteki komponentów Material-UI. 
  Po wszystkich zmianach wizualnych, aplikacja prezentuje się następująco:
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{client_app/home.png}
    \caption{Finalny wygląd aplikacji.}
    \label{fig:final-view}
  \end{figure}
}

\section{Aplikacja od strony użytkownika}
{
  Po otwarciu aplikacji oczom klienta ukaże się strona główna, zawierająca takie elementy jak:
  \begin{itemize}
    \item wyszukiwarkę wydarzeń po nazwie
    \item filtr po typach wydarzeń
    \item przyciski do logowania i rejestracji użytkownika
    \item listę wszystkich dostępnych na stronie wydarzeń
  \end{itemize}
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{client_app/home.png}
    \caption{Strona główna aplikacji.}
    \label{fig:home-page}
  \end{figure}
  Z poziomu strony głównej użytkownik ma kilka opcji, może wybrać bezpośrednio interesujące go wydarzenie i przejść do niego, zarejestrować się, 
  zalogować się oraz filtrować wydarzenia według jego uznania. 
  Filtrowanie odbywa się po typie wydarzeń i jest to zrobione w formie listy rozwijanej, oraz wyszukiwać, w odpowiednim polu, po nazwie wydarzenia.
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{client_app/search.png}
    \caption{Wyszukiwanie po frazie.}
    \label{fig:search-field}
  \end{figure}
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{client_app/filter.png}
    \caption{Filtrowanie po typie wydarzenia}
    \label{fig:filter}
  \end{figure}
  Po naciśnięciu jednej z kart wydarzenia, widocznych na stronie głównej, klient zostaje przeniesiony na stronę konkretnego wydarzenia, 
  gdzie może nieco więcej dowiedzieć się o danym evencie i kupić na nie bilet.
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{client_app/event.png}
    \caption{Strona konkretnego wydarzenia, w tym przypadku Orange Warsaw.}
    \label{fig:event-page}
  \end{figure} 
  Kupowanie biletu jest dostępne zarówno dla użytkowników zalogowanych, jak i niezalogowanych. 
  Po naciśnięciu na przycisk "Buy Ticket" klient jest przenoszony do forma, umożliwiającego podanie danych do realizacji zakupu.
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{client_app/payment_guest.png}
    \caption{Form do zebrania danych, niezbędnych do realizacji zakupu biletu.}
    \label{fig:payment-guest}
  \end{figure}
  Po podanych poprawnych danych, w formacie wymaganym przez aplikacji, użytkownik jest informowany o pomyślnie zrealizowanym zakupie, lub w przypadku gdy coś poszło 
  nie tak zostaje przeniesiony na stronę informującą o niepowodzeniu.\\
  Użytkownik ma możliwość założenia konta lub jeśli już je posiada zalogowania się na nie. 
  Minimalnie zmienia to widok aplikacji, zamiast przycisków "Sign In" oraz "Sign Up" pojawiają się dwa inne przyciski "Purchase history" oraz "Logout".
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{client_app/logged_in.png}
    \caption{Strona główna aplikacji, po zalogowaniu.}
    \label{fig:signed-in}
  \end{figure}
  Pierwszy z wymienionych nowych przycisków, daje użytkownikowi opcję niedostępną w innym przypadku, a konkretniej podgląd wszystkich biletów, które zakupił, wraz z ich kodem QR.
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{client_app/purchase_history.png}
    \caption{Lista biletów klienta, dostępna za pomocą Purchase History.}
    \label{fig:purchase_his}
  \end{figure}
  Dodatkowym atutem zalogowanych użytkowników jest fakt, iż przy kupnie biletu nie muszą oni ponownie podawać tych samych danych, które podawali przy rejestracji np. imię czy numer telefonu. 
  Jedyne dane jakie są zmuszeni podać to dane karty płatniczej. Co zdecydowanie przyśpiesza i ułatwia obcowanie z aplikacją, przy częstym jej użytkowaniu.\\
  Tak prezentuję się aplikacja od strony klienta, jest wyjątkowo, prosta, czytelna i łatwa w obsłudze. 
  Celem nie było sprawienie, aby użytkownik był przytłoczony tym co widzi, tylko w łatwy sposób, mógł osiągnąć cele takie jak: kupno biletu lub zdobycie informacji o wydarzeniu.
}

\section{Podsumowanie}
{
  Głównym celem i założeniem pracy było zaprojektowanie i stworzenie aplikacji webowej do promocji wydarzeń kulturowych i sprzedaży biletów na nie. 
  Udało się spełnić założony cel przy wykorzystaniu technologii takich jak: React.JS, Node.JS czy MongoDB. 
  Aplikacja sama w sobie nie jest rewolucyjna, celem pracy nie było odkrywanie koła na nowo, 
  tylko stworzenie aplikacji umożliwiającej potencjalnemu klientowi, w prosty i szybki sposób zapoznanie się z dostępnymi wydarzeniami, informacjami o nich oraz zakup biletów. 
  Wszystkie te założenia zostały spełnione, interfejs jest bardzo prosty i przejrzysty, wydarzenia są widoczne już na stronie głównej, 
  co dodatkowo sprawia, że użytkownik, nie musi przeszukiwać strony aby je odnaleźć, 
  płatności są realizowane w przystępny sposób oraz same bilety są w najprostszej i jednocześnie najwygodniejszej postaci, w formie kodów QR. 
  Dodatkowo w samej pracy przybliżone zostały takie kwestie jak bazy danych, ich typy i zastosowanie, technika tworzenia aplikacji jaką jest model kaskadowy, typy aplikacji webowych, Rest API,
  najpopularniejsze metody płatności w internecie i przeanalizowane zostały konkurencyjne portale do sprzedaży biletów na wydarzenia kulturowe. 
  Zaprezentowane zostały również narzędzia, jak również technologie, które zostały wykorzystane na potrzeby aplikacji, pokrótce również zostało omówione, 
  jakie potencjalne zmiany i rozszerzenia samej aplikacji mogą się znaleźć, aby doświadczenie w obcowaniu z aplikacją było jeszcze lepsze. 
  Krok po kroku zostało pokazane jak powstawała sama aplikacja, jakie funkcjonalności były po kolei dodawane i jaki jest efekt finalny. 
  Dodatkowym rozdziałem jest zaprezentowanie aplikacji od strony użytkownika, znajdują się w nim screeny oraz krótkie opisy, przez jaki proces przechodzi każdy użytkownik aplikacji.
}

\section{Możliwości dalszego rozwoju aplikacji}
{
  Możliwości dalszego rozwoju aplikacji są ogromne i różne. 
  Pierwszą przykładową jest stworzenie systemu newslettera, na który użytkownik mógłby się zapisać i otrzymywać maile z najnowszymi informacjami i zaproszeniami na wydarzenia.\\ 
  Inną, istotną funkcjonalnością mogłoby być resetowanie hasła użytkownika. W chwili obecnej nie występuje żadna możliwość resetu hasła, co stanowi bardzo ważny element 
  każdej aplikacji, w której w grę wchodzi logowanie się użytkowników.\\
  Również bardzo przydatne byłaby obsługa innych typów płatności, aktualnie jest to tylko płatność danymi karty płatniczej. 
  Szczególnie wartymi dodania byłaby płatność PayPalem, Blikiem czy zwykłym przelewem bankowym.\\
  Bardzo istotnym jest stworzenie systemu sprawdzającego bilety i kody QR. 
  Aktualnie nie ma żadnej weryfikacji biletów, więc generowane kody są w zasadzie pustym zlepkiem pikseli. 
  Jest to funkcja o tyle istotna, że żadna firma nie zdecyduje się na publikowanie swojego wydarzenia i dystrybucji biletów przez stronę, która nie daje możliwości, 
  sprawdzenia czy kod QR prezentowany przez klienta odpowiada temu, który został zakupiony i czy jest on powiązany z konkretnym wydarzeniem.\\
  Kluczową funkcją mogłaby okazać się obsługa płatności i języków innych krajów. 
  Aktualnie płatność odbywa się w złotówkach, a językiem figurującym w aplikacji jest język angielski. 
  Język angielski, ma to do siebie, że jest znany przez bardzo szerokie grono ludzi, jednakże płatność dla obcokrajowców, w innej walucie, może okazać się niekorzystna.
  Dochodzą takie opłaty jak chociażby przewalutowanie, a dodatkowe opłaty nigdy nie są mile widziane przez klientów.\\
  Ostatnim przykładową możliwością rozwoju aplikacji jest stworzenie aplikacji mobilnej, w której nawet niezalogowany użytkownik, 
  miałby dostęp do wszystkich posiadanych przez siebie biletów, tak jak jest to chociażby w GoingApp.
}

\clearpage

\section{Bibliografia}
{
  \printbibliography
  \clearpage
}

\section{Spis rysunków}
{
  \listoffigures
  \clearpage
}

\section{Spis tabel}
{
  \listoftables
  \clearpage
}
\section{Spis listingów}
{
  \lstlistoflistings
}

\end{sloppypar}
\end{document}
